---
layout: post
title: Programming Language
date: 2020-09-01 16:30:00 +0900
category: Lecture
---

# 프로그래밍 언어론 :)

> 컴파일러 구현 단계
1. 원시 코드
2. 어휘 분석
3. 구문 분석
4. 의미 분석 <여기까지 전반부>

5. 중간 코드 최적화
6. 코드 생성
7. 목적 코드 최적화<여기까지 후반부>

8. 목적 프로그램

구문분석기는 어휘 분석기의 결과인 토큰 열로부터 트리를 구성하는 일을 함.
이를 syntax tree라고 함

FSM
AST(Abstract Syntax Tree)

RDP(Recursive Descent Parser) : 순환 재귀 하강
1. 각 비단말 기호의 구문 규칙에 대해 하나의 프로시저를 만들되, 우변을 모사하도록 프로시저를 만듦
2. 우변을 모사할 때 단말 기호라면 (터미널이라면) 일치하는지 재검사하고, 비단말 기호라면 (논터미널이라면) 해당 프로시저를 호출

이 결과가 구문 분석과 같다.

이 재귀함수의 집합을 이용하면 구문 트리를 쉽게 만들 수 있다.

<K> ::= <S> '\n' <K> | EOF
<S> ::\ '(' <S> ')'<S>} 


<pre>
<code>
#include <iostream>
#include <cstdio>
#include <cstdlib>
using namespace std;
int lookahead = 0;
void K(), S();
int nexttoken();
void match(int);
void error(char c);

int main() {
        lookahead = nexttoken();
        K();
        return 0;
}

int nexttoken() {
        return getchar();
}
void match(int token) {
        if (lookahead == token)
                lookahead = nexttoken();
        else
                error(token);
}
void error(char c) {
        cout << "Sysntax Error : " << c << "\n";
        exit(-1);
}
void K() {
        if (lookahead==EOF)
                ;
        else {
                S(); match('\n'); K();
        }
}
void S() {
        if (lookahead=='(') {
                        match('('); S(); match(')'); S();
        }
        else
                ;)
}
</code>
</pre>





> 6주차 첫번째 수업
학습목표
1) 타입의 개념
   - 데이터 집합 
      ex) 정수형 집합 { ... -3, -2, -1, 0, 1, 2, 3 ... }
   - 연산 집합
      ex) 연산자 집합 { =, +, -, * , /, % ... }
   - 타입 안정성(type safety) : 강타입(strongly typed), 약타입(weakly typed), 무타입 (상대적인 분류이며 정확한 분류 기준은 없다)
     - 타입 에러를 일으키지 않을 것이 보장이 된다
2) 타입의 분류기준
   - 원시타입 (primitive type)
   - 사용자정의타입 (user-defined type)
   - 단순타입
   - 복합타입(구조체)
3) 단순타입
   - 정수형
   - 실수형 (IEEE 754) : 부호/지수부/가수부
     float (32bit) 단정밀도 single
     1bit / 8bit / 23bit
     double (64bit) 배정밀도 double
     1bit / 11bit / 52bit
     (예) 십진수를 16진수로 바꾸기
      11.125(10) -> hexadecimal
      1) 부호비트
      0 
      2) 소수점 앞자리와 뒷자리를 2진수화 시킨다.
      1011.001
      10110.01 * 2e-1
      101.1001 * 2e+1
      3) 정규화 (소수점을 이동시켜 왼쪽에 1만 남게 만든다)
      1.011001 * 2e+3
      4) 가수부 부분에 정규화된 소수점 오른쪽 부분을 먼저 넣고 남는 부분은 0으로 채워넣는다.
      0 / 지수 / 011001 00000000000000000
      single일 경우 bias +127
      (double일 경우 bias +1023)
      0000 0000  -127  (특수용도)
      0000 0001  -126  (e min)
      ...
      0111 1111      0
      1000 0000      1
      1000 0001      2
      1000 0010      3 (130)
      ...
      1111 1110  +127  (e max)
      1111 1111  +128  (특수용도)
  
      0 / 1000 0010 / 011001 00000000000000000
      0100 0001 0011 0010 0000 0000 0000 0000
      0x41320000

	121.0(10) vs 0.0062(10)
	0111 1001.0 (2)             ->    1.111001 * 2e+6
	0.000000011001011... (2)   ->    1.1001011... * 2e-8

	6+127 = 133(10)  = 1000 0101(2)
	-8+127 = 119(10) = 0111 0111(2)
        참고:http://binaryconvert.com/

> 6주차 두번째 수업
3) 단순타입
   - 정수형
   - 실수형
   - 문자형 (두 가지 방식: ASCII, Unicode)
      C/C++ 
	1byte char
	2byte wchar_t
      JAVA 
	2byte char
      Go
	1~4byte rune literal(가변적인 길이 가짐)
   - 논리형
	true, false
   - 열거형
4) 복합타입
   - 배열(array)
     - 같은 타입의 데이터의 모임
     - primitive 타입의 배열은 초기 값을 가진다.(integer일 때 0, 실수형일때 0.0)
     - refernece(참조형) 타입의 경우 배열 선언 시 초기값은 Null값을 가진다
   - 문자열형(String)
     - sequence of byte(연속적으로 나열되어 있는 바이트)
     - immuatable(한번 만들어지면 수정 불가능)
     <pre><code>
     for idx, r := range "123" {
             fmt.Println(idx, r)
     }
     </code></pre>
     출력 : 0 49 / 1 50 / 2 51
   - 연관배열(Associated Array Type) dictionary(파이썬), map(c++) 구조
     - 연관배열(key, value), 해싱 (hash table)
       O(1),  Worst case O(n) 시간복잡도 list와 유사
       직접적인 산술 연산에 적용해서 아이템이 저장되어 있는
       테이블의 주소를 계산하여 아이템에 접근.
   - 구조체, 공용체
   - 포인터형, 참조형 (cpp 에서 int &rid = id)



> 7주차
학습목표
1) 수식, 식, 표현식 (Expression)
  * 값을 나타내는 표현... 프언에서는: <strong>자료</strong>
  * 계산을 표현하는 기본적인 수단들로 구성이 됨(연산자, 피연산자 등)
    * 단항: System.out.println(++a)
    * 이항: System.out.println(a+2)
      * LISP언어에서는 (= a 2) 라고도 씀(언어마다 차이가 있음)
    * 삼항: String k = (i%2!=) ? "홀수":"짝수"
    * sizeof, multiple(a, b)도 연산자가 될 수 있음
2) 식의 평가
   * 연산자의 평가순서 (Operator Evaluation)
     * APL: 우결합("<-", 우에서 좌결합), 우선순위 동등 (예. a-b+c)
       * c++
       <img src="{{ site.baseurl }}/images/aplc++.png" width="30%" height="30%">
       <img src="{{ site.baseurl }}/images/apl2c++.png" width="30%" height="30%">
     * 좌결합
       * JAVA
       <img src="{{ site.baseurl }}/images/adljava.png" width="30%" height="30%">
     * Ada: &#42;&#42;(지수연산자) But 결합법칙이 성립하지 않기 때문에 a&#42;&#42;b&#42;&#42;c : 신텍스 에러 발생
   * 피연산자의 평가순서 (Operand Evaluation)
3) 단락회로 평가 (Short Circuit Evaluation)
   * 모든 operate를 수행하지 않더라도 값이 나오는 경우(a값이 영향을 미치지 않음)
   * 예) (a || true) =  true, (a && true) = false
4) 중복 연산자 (Overloaded Operators)
   * 예) System.out.println("inha" + "univ") -> inha univ
5) 문장 (Statements)
   * 선언문
     * 변수는 선언문을 통해 변수 이름과 타입을 바인딩해야 이용 가능
     * 함수도 선언문을 통해 명시하여야 사용 가능
   * 실행문
     * 대입문 ( := Algol, Pascal, Ada 등 // = Cpp, Java, Go 등)
       * 약타입 언어: 묵시적 형변환 일어남 ex)c++
       * 강타입 언어: 형변환 일어나지 않음 ex)java, go
     * 제어문
       * 조건문 if, switch
       * 반복문 for, while 등