---
layout: post
title: Computer Network Lab
date: 2020-09-01 16:30:00 +0900
category: Lecture
---

# Computer Network 실습 :)

### Chapter 01-1. 네트워크 프로그래밍과 소켓의 이해

> #### 네트워크 프로그래밍이란?
* 둘 이상의 컴퓨터 사이에서의 데이터 송수신 프로그램
* 이 프로그램은 소켓이라는 것을 기반으로 프로그래밍
* 따라서 소켓 프로그래밍이라고 부르기도 함

> #### 소켓이란?
* 운영체제에서 제공해주는 소프트웨어적인 장치
* 소켓을 활용하면 데이터 송수신에 대한 물리적, 소프트웨어적 세세한 내용을 신경 쓸 필요가 없다는 장점이 있음

* 소켓의 생성(전화기에 장만에 비유)
  * 전화를 거는 용도의 소켓과 전화를 수신하는 용도의 소켓 생성 방법이 다름
  * 전화를 거는 용도의 소켓 = client (서버로부터 서비스 받음)
  * 전화를 받는 용도의 소켓 = server

* 전화를 받는 쪽이 server 소켓
* 전화 받기 위해서 네 가지 단계 거쳐야 함
1. 전화기가 있어야 함 = 소켓의 생성
  * 소켓 생성
  * 성공 시 파일 디스크립터 반환, 실패 시 -1 반환
2. 전화기에 전화번호가 부여되어 있어야 함 = IP와 PORT 번호의 할당
  * 생성된 소켓에 주소 정보를 부여
  * bind라는 함수를 통해 소켓에 부여
  * IP주소와 Port번호로 구성이 됨
  * 성공 시 0, 실패 시 -1 반환
3. 전화기의 전화 선이 연결되어야 함 = 연결 요청 가능상태로 변경
  * listen 함수를 호출하면 소켓이 전화를 받을 수 있는 상태가 됨
  * 전화를 받는 쪽에만 필요, 전화를 거는 쪽은 필요X
  * 성공 시 0, 실패 시 -1 반환
4. 전화가 오면 전화를 받음 = 연결 요청에 대한 수락
  * accept 함수를 호출하여 클라이언트로부터 걸려오는 전화를 받을 수 있음
  * 연결 요청의 수락
  * 연결 요청이 수락되어야 데이터의 송수신이 가능
  * 수락된 이후에 데이터의 송수신은 양방향으로 가능
  * accpet 함수 호출 이후에는 데이터의 송수신이 가능
  * accpet 함수는 blocking 함수이기 때문에 연결 요청이 있을 때에만 반환함
  * 성공 시 파일 디스크립터 반환, 실패 시 -1 반환

* 클라이언트 소켓 생성 과정(전화를 거는 소켓)
  * 서버 소켓에 비해 구현이 간단
1. 소켓 생성
  * 소켓 생성
2. 연결의 요청
  * connect 함수 호출을 통해 서버 측에 연결 요청
  * 성공 시 0, 실패 시 -1 반환

> hello_server.c
> hello_client.c

> 컴파일 방법
gcc hello_server.c -0 hserver
> 실행 방법
./hserver

* 로컬 컴퓨터 주소 = loop back 주소
* 루프 백 주소 이용하여 실행하면 됨

* 서로 다른 두 개의 컴퓨터에서 실행시키고 싶다면 루프 백 주소가 아닌 IP 주소 넣어서 실행하면 됨

### Chapter 01-2. 리눅스 기반 파일 조작하기
> 저 수준 파일 입출력
* 저 수준 파일 입출력
  * 리눅스는 소켓도 파일로 간주하기 때문에 저 수준 파일 입출력 함수를 기반으로 소켓 기반의 데이터 송수신이 가능
* 파일 디스크립터
  * 운영체제가 만든 파일을 구분하기 위한 일종의 숫자
  * 저 수준 파일 입출력 함수는 입출력을 목적으로 파일 디스크립터를 요구
* 파일 열기와 닫기
  * open
    * path, flag 전달
    * flag: 파일의 오픈 모드 정보 전달
  * close
    * fd 전달

> 파일에 데이터 쓰기
* write
  * fd, 전송할 데이터가 저장된 버퍼의 주소 값, 전송할 데이터의 바이트 수 전달

> 파일에서 데이터 읽기
* read
  * fd, 수신한 데이터를 저장할 버퍼의 주소 값, 수신할 최대 바이트 수 전달

> chapter 01-3. 윈도우 기반으로 구현하기 - 생략

> 프로토콜 체계
* 프로토콜도 그 종류에 따라서 부류가 나뉘는데, 그 부류를 프로토콜 체계라 함
* 프로토콜의 체계 PF_INET은 IPv4 인터넷 프로토콜 체계를 의미하며, 이를 기반으로 소켓 프로그래밍을 학습

> 소켓의 타입
* 소켓의 타입
  * 데이터 전송 방식을 의미
  * 소켓이 생성될 때 소켓의 타입도 결정되어야 함
* 프로토콜 체계 PF_INET의 대표적인 소켓 타입 둘
  * 연결 지향형 소켓 타입
  * 비 연결 지향형 소켓 타입

> 두 타입의 소켓
* 연결지향형 소켓의 데이터 전송 특성(TCP소켓)
  * SOCK_STREAM
  * socket(PF_INET, SOCK_STREAM, 마지막인자??)
  * 중간에 데이터가 소멸되지 않음(1대1구조이기 때문)
  * 전송 순서대로 데이터가 수신됨
    * TCP 프로토콜에서 버퍼를 활용하여 데이터를 순서대로 쌓아놓음
  * 데이터의 경계가 존재하지 않음
  * 소켓 대 소켓의 연결은 반드시 1대1 구조
  * TCP/IP: IP위에 TCP가 올려진 것
* 비 연결지향형 소켓의 데이터 전송 특성(UDP소켓)
  * SOCK_DGRAM
  * 전송순서에 상관없이 빠른 속도의 전송일 지향
  * 데이터 손실 및 파손의 우려 있음
  * 데이터의 경계가 존재
  * 한번에 전송할 수 있는 데이터의 크기가 제한됨

> 프로토콜의 최종 선택! (마지막 인자 관련)
* 마지막 인자는 최종의 프로토콜을 선택
* 연결지향형 데이터 소켓
  * 첫번째 인자: PF_INET
  * 두번째 인자: SOCK_STREAM
  * 세번째 인자: IPPROTO_TCP
* 비연결지향형 데이터 소켓
  * 첫번째 인자: PF_INET
  * 두번째 인자: SOCK_DGRAM
  * 세번째 인자: IPPROTO_UDP
* 첫번째, 두번째 인자로 전달된 정보를 통해서 소켓의 프로토콜이 사실상 결정이 되기 때문에 세번째 인자를 0을 전달해도 된다.

> 소켓 생성 시 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) 이용

### 3장. 주소 체계와 데이터 정렬

> #### 3-1. 소켓에 할당되는 IP주소와 PORT번호
* 인터넷 주소
  * 인터넷상에서 컴퓨터를 구분하는 목적으로 사용되는 주소
  * 4바이트 주소체계인 IPv3와 16바이트 주소치계인 IPv6가 존재
  * 네트워크 주소와 호스트 주소로 나누어짐
    * 네트워크 주소: 네트워크 찾는데 이용
    * 호스트 주소: 네트워크 주소를 통해 네트워크를 찾고나서, 호스트 주소를 이용하여 호스트를 구분
  * 클래스 구분 이유: IP를 효율적으로 관리하기 위함
    * 클래스 A: 하나의 네트워크가 약 2^24개의 호스트를 생성
    * 클래스 B: 하나의 네트워크가 약 2^16개의 호스트 주소 생성
    * 클래서 C: 하나의 네트워크가 약 2^8개의 호스트 ID 생성
    필요로 하는 호스트의 수만큼 네트워크 주소를 할당하여 IP주소의 낭비를 최소화할 수 있음

    * IP주소만 보고 어느 클래스에 속하는지 구분방법
* 클래스 별 네트워크 주소와 호스트 주소의 경계
  * 클래스 A의 첫번째 범위: 0이상 127이하(0 ~ 0111111)
  * 클래스 B의 첫번째 바이트 범위: 128이상 191이하 (10 ~ )
  * 클래스 C의 첫번째 바이트 범위: 192이상 223이하 (110 ~)
  즉,
  * 클래스 a의 첫번째 비트는 항상 0으로 시작
  * 첫번째 바이트 정보만 참조해도 IP주소와 클래스 구분이 가능하며, 이로 인해서 네트워크 주소와 호스트 주소의 경계 구분이 가능.
* 소켓의 구분에 활용되는 PORT번호
  * 하나의 프로그램 내에서는 둘 이상의 소켓이 존재할 수 있으므로, 둘 이상의 PORT가 하나의 프로그램에 의해 할당될 수 있음
  * 16비트(2바이트)로 표현, 따라서 그 값은 0이상 65535이하
  * 0~1023은 잘 알려진 포트 번호라 하여, 이미 용도가 결정되어 있음

### 3.2 주소 정보의 표현(4주차)