---
layout: post
title: Computer Network Lab
date: 2020-09-01 16:30:00 +0900
category: Lecture
---

# Computer Network 실습 :)

### Chapter 01-1. 네트워크 프로그래밍과 소켓의 이해

> #### 네트워크 프로그래밍이란?
* 둘 이상의 컴퓨터 사이에서의 데이터 송수신 프로그램
* 이 프로그램은 소켓이라는 것을 기반으로 프로그래밍
* 따라서 소켓 프로그래밍이라고 부르기도 함

> #### 소켓이란?
* 운영체제에서 제공해주는 소프트웨어적인 장치
* 소켓을 활용하면 데이터 송수신에 대한 물리적, 소프트웨어적 세세한 내용을 신경 쓸 필요가 없다는 장점이 있음

* 소켓의 생성(전화기에 장만에 비유)
  * 전화를 거는 용도의 소켓과 전화를 수신하는 용도의 소켓 생성 방법이 다름
  * 전화를 거는 용도의 소켓 = client (서버로부터 서비스 받음)
  * 전화를 받는 용도의 소켓 = server

* 전화를 받는 쪽이 server 소켓
* 전화 받기 위해서 네 가지 단계 거쳐야 함
1. 전화기가 있어야 함 = 소켓의 생성
  * 소켓 생성
  * 성공 시 파일 디스크립터 반환, 실패 시 -1 반환
2. 전화기에 전화번호가 부여되어 있어야 함 = IP와 PORT 번호의 할당
  * 생성된 소켓에 주소 정보를 부여
  * bind라는 함수를 통해 소켓에 부여
  * IP주소와 Port번호로 구성이 됨
  * 성공 시 0, 실패 시 -1 반환
3. 전화기의 전화 선이 연결되어야 함 = 연결 요청 가능상태로 변경
  * listen 함수를 호출하면 소켓이 전화를 받을 수 있는 상태가 됨
  * 전화를 받는 쪽에만 필요, 전화를 거는 쪽은 필요X
  * 성공 시 0, 실패 시 -1 반환
4. 전화가 오면 전화를 받음 = 연결 요청에 대한 수락
  * accept 함수를 호출하여 클라이언트로부터 걸려오는 전화를 받을 수 있음
  * 연결 요청의 수락
  * 연결 요청이 수락되어야 데이터의 송수신이 가능
  * 수락된 이후에 데이터의 송수신은 양방향으로 가능
  * accpet 함수 호출 이후에는 데이터의 송수신이 가능
  * accpet 함수는 blocking 함수이기 때문에 연결 요청이 있을 때에만 반환함
  * 성공 시 파일 디스크립터 반환, 실패 시 -1 반환

* 클라이언트 소켓 생성 과정(전화를 거는 소켓)
  * 서버 소켓에 비해 구현이 간단
1. 소켓 생성
  * 소켓 생성
2. 연결의 요청
  * connect 함수 호출을 통해 서버 측에 연결 요청
  * 성공 시 0, 실패 시 -1 반환

> hello_server.c
> hello_client.c

> 컴파일 방법
gcc hello_server.c -0 hserver
> 실행 방법
./hserver

* 로컬 컴퓨터 주소 = loop back 주소
* 루프 백 주소 이용하여 실행하면 됨

* 서로 다른 두 개의 컴퓨터에서 실행시키고 싶다면 루프 백 주소가 아닌 IP 주소 넣어서 실행하면 됨

### Chapter 01-2. 리눅스 기반 파일 조작하기
> 저 수준 파일 입출력
* 저 수준 파일 입출력
  * 리눅스는 소켓도 파일로 간주하기 때문에 저 수준 파일 입출력 함수를 기반으로 소켓 기반의 데이터 송수신이 가능
* 파일 디스크립터
  * 운영체제가 만든 파일을 구분하기 위한 일종의 숫자
  * 저 수준 파일 입출력 함수는 입출력을 목적으로 파일 디스크립터를 요구
* 파일 열기와 닫기
  * open
    * path, flag 전달
    * flag: 파일의 오픈 모드 정보 전달
  * close
    * fd 전달

> 파일에 데이터 쓰기
* write
  * fd, 전송할 데이터가 저장된 버퍼의 주소 값, 전송할 데이터의 바이트 수 전달

> 파일에서 데이터 읽기
* read
  * fd, 수신한 데이터를 저장할 버퍼의 주소 값, 수신할 최대 바이트 수 전달

> chapter 01-3. 윈도우 기반으로 구현하기 - 생략

> 프로토콜 체계
* 프로토콜도 그 종류에 따라서 부류가 나뉘는데, 그 부류를 프로토콜 체계라 함
* 프로토콜의 체계 PF_INET은 IPv4 인터넷 프로토콜 체계를 의미하며, 이를 기반으로 소켓 프로그래밍을 학습

> 소켓의 타입
* 소켓의 타입
  * 데이터 전송 방식을 의미
  * 소켓이 생성될 때 소켓의 타입도 결정되어야 함
* 프로토콜 체계 PF_INET의 대표적인 소켓 타입 둘
  * 연결 지향형 소켓 타입
  * 비 연결 지향형 소켓 타입

> 두 타입의 소켓
* 연결지향형 소켓의 데이터 전송 특성(TCP소켓)
  * SOCK_STREAM
  * socket(PF_INET, SOCK_STREAM, 마지막인자??)
  * 중간에 데이터가 소멸되지 않음(1대1구조이기 때문)
  * 전송 순서대로 데이터가 수신됨
    * TCP 프로토콜에서 버퍼를 활용하여 데이터를 순서대로 쌓아놓음
  * 데이터의 경계가 존재하지 않음
  * 소켓 대 소켓의 연결은 반드시 1대1 구조
  * TCP/IP: IP위에 TCP가 올려진 것
* 비 연결지향형 소켓의 데이터 전송 특성(UDP소켓)
  * SOCK_DGRAM
  * 전송순서에 상관없이 빠른 속도의 전송일 지향
  * 데이터 손실 및 파손의 우려 있음
  * 데이터의 경계가 존재
  * 한번에 전송할 수 있는 데이터의 크기가 제한됨

> 프로토콜의 최종 선택! (마지막 인자 관련)
* 마지막 인자는 최종의 프로토콜을 선택
* 연결지향형 데이터 소켓
  * 첫번째 인자: PF_INET
  * 두번째 인자: SOCK_STREAM
  * 세번째 인자: IPPROTO_TCP
* 비연결지향형 데이터 소켓
  * 첫번째 인자: PF_INET
  * 두번째 인자: SOCK_DGRAM
  * 세번째 인자: IPPROTO_UDP
* 첫번째, 두번째 인자로 전달된 정보를 통해서 소켓의 프로토콜이 사실상 결정이 되기 때문에 세번째 인자를 0을 전달해도 된다.

> 소켓 생성 시 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) 이용

### 3장. 주소 체계와 데이터 정렬

> #### 3-1. 소켓에 할당되는 IP주소와 PORT번호
* 인터넷 주소
  * 인터넷상에서 컴퓨터를 구분하는 목적으로 사용되는 주소
  * 4바이트 주소체계인 IPv3와 16바이트 주소치계인 IPv6가 존재
  * 네트워크 주소와 호스트 주소로 나누어짐
    * 네트워크 주소: 네트워크 찾는데 이용
    * 호스트 주소: 네트워크 주소를 통해 네트워크를 찾고나서, 호스트 주소를 이용하여 호스트를 구분
  * 클래스 구분 이유: IP를 효율적으로 관리하기 위함
    * 클래스 A: 하나의 네트워크가 약 2^24개의 호스트를 생성
    * 클래스 B: 하나의 네트워크가 약 2^16개의 호스트 주소 생성
    * 클래서 C: 하나의 네트워크가 약 2^8개의 호스트 ID 생성
    필요로 하는 호스트의 수만큼 네트워크 주소를 할당하여 IP주소의 낭비를 최소화할 수 있음

    * IP주소만 보고 어느 클래스에 속하는지 구분방법
* 클래스 별 네트워크 주소와 호스트 주소의 경계
  * 클래스 A의 첫번째 범위: 0이상 127이하(0 ~ 0111111)
  * 클래스 B의 첫번째 바이트 범위: 128이상 191이하 (10 ~ )
  * 클래스 C의 첫번째 바이트 범위: 192이상 223이하 (110 ~)
  즉,
  * 클래스 a의 첫번째 비트는 항상 0으로 시작
  * 첫번째 바이트 정보만 참조해도 IP주소와 클래스 구분이 가능하며, 이로 인해서 네트워크 주소와 호스트 주소의 경계 구분이 가능.
* 소켓의 구분에 활용되는 PORT번호
  * 하나의 프로그램 내에서는 둘 이상의 소켓이 존재할 수 있으므로, 둘 이상의 PORT가 하나의 프로그램에 의해 할당될 수 있음
  * 16비트(2바이트)로 표현, 따라서 그 값은 0이상 65535이하
  * 0~1023은 잘 알려진 포트 번호라 하여, 이미 용도가 결정되어 있음

> ### 3.2 주소 정보의 표현(4주차)
* 구조체 sockadd_in 의 멤버에 대한 분석
  * 멤버 sin_family
    * 주소 체계 정보 저장
    * AF_INET: IPv4 인터넷 프로토콜에 적용하는 주소체계
    * AF_INET: IPv4 인터넷 프로토콜에 적용하는 주소체계
    * AF_LOCAL: 로컬 통신을 위한 유닉스 프로토콜의 주소체계
  * 멤버 sin_port
    * 16비트 PORT 번호 저장
    * 네트워크 바이트 순서로 저장
  * 멤버 sin_addr
    * 32비트 IP주소정보 저장
    * 네트워크 바이트 순서로 저장
    * 멤버 sin_addr의 구조체 자료형 in_addr 사실상 32비트 정수자료형
  * 멤버 sin_zero[8]
    * 특별한 의미 X 그러나 반드시 0으로 채워주어야 함
    * 남은 8 바이트...
* 구조체 solckaddr_in의 활용 예<br>
  구조체 sockaddr은 다양한 주소체계의 주소 정보를 담을 수 있도록 정의되었다. 그래서 IPv4의 주소정보를 담기가 불편하다. 이에 동일한 바이트 열을 구성하는 구조체 sockaddr_in이 정의되었으며, 이를 이용해서 쉽게 IPv4의 주소 정보를 담을 수 있다.<br>

#### Chapter 03-3. 네트워크 바이트 순서와 인터넷 주소 변환
* CPU에 따라 달라지는 정수의 표현
  * 네트워크 바이트 순서가 필요하게 된 이유: CPU에 따라서 달라지는 정수의 표현 때문
  * 정수 1을 저장하는 방식
    * 상위 바이트를 상위 메모리주소(작은 번지수)에 저장하는 방식(빅 엔디안)
    * 상위 바이트를 하위 메모리주소(큰 번지수)에 저장하는 방식(리틀 엔디안)
  * 하나의 컴퓨터를 사용할 때는 저장 및 해석을 CPU가 해주기 때문에 문제가 되지 않지만 서로 다른 컴퓨터가 데이터를 주고 받을 때는 이와 같은 저장 방식으로 인해 문제가 발생할 수 있음. 이를 해결하기 위해 네트워크 사이에서 데이터 통신 방법을 통일시키고, 이 통일된 방식의 이름을 "네트워크 바이트 순서"라고 부름
* 바이트 순서와 네트워크 바이트 순서
  * 빅엔디안을 기준으로 통일하게 됨
* 바이트 순서의 전환 방법
  * 바이트 변환 함수 사용
  * short htons() : host to network
  * unsigned short ntohs(unsigned short);
  * unsigned long htonl()
  * ...
* 정리: 처음에는 sock_addr_in이라는 구조체에 주소 정보를 담는 방법, CPU마다 데이터를 저장하는 방법이 달라 네트워크 바이트 순서로 변환해야함을 배움.


#### Chapter 03-4. 인터넷 주소의 초기화 할당
* 문자열 정보를 네트워크 바이트 순서의 정수로 변환
  * inet_addr(const char* string)
    * 인자로 IP주소 정보를 32비트의 정수형으로 변환을 해서 전달
    * 문자열 형태의 IP주소를 addr1, addr2에 담고 해당 함수를 통해 32비트 정수형으로 바꿀 수 있음
    * 점으로 찍힌 문자열을 32비트의 정수형으로 변환 + 빅 엔디안 방식으로 변환까지 해줌
  * inet_aton(const char* string, struct int_addr* addr);
    * inet_addr과 같은 결과를 가지고 있지만 변환된 결과를 바로 저장을 해준다
    * string: 변환할 IP주소 정보를 담고 있는 문자열의 주소 값 전달
    * addr: 변환된 정보를 저장할 in_addr 구조체 변수의 주소 값 전달
  * inet_ntoa
    * inet_aton 함수의 반대 기능 제공
    * 네트워크 바이트 순서로 정렬된 정수형 IP주소정보를 우리가 눈으로 쉽게 인식할 수 있는 문자열의 형태로 변환
* 인터넷 주소의 초기화 방법
  1. struct sockaddr_in addr;
  2. IP주소 문자열 선언
  3. PORT번호 문자열 선언
  4. memset 함수를 통해 구조체 변수 addr의 모든 멤버 0으로 초기화
  5. 주소체계 지정
  6. 문자열 기반의 IP주소 초기화(inet_addr 사용)
  7. 문자열 기반의 PORT 번호 초기화(atoi 사용)
  * 서버 측에서는 bind를 통해서 자신의 주소 부여
  * 클라이언트 측에서는 connet를 통해서 자신이 연결하고자 하는 주소 정보를 서버에게 전달

### Chapter 4.TCP 기반 서버/클라이언트

> #### Chapter 04-1. TCP와 UDP에 대한 이해
* TCP/IP 프로토콜 스택이란?
  * 큰 문제를 작게 나눠서 계층화 한 결과
  * 각 스택 별 영역을 전문화하고 표준화 함
  * 7계층으로 세분화가 되며, 4계층으로도 표현함
* LINK & IP 계층
  * LINK: 데이터를 주고 받기 위한 물리적 영역
  * IP: 경로의 설정과 관련이 있는 프로토콜
* TCP/UDP
  * TCP: 데이터의 전송을 보장하는 신뢰성이 있는 프로토콜
    * 받은 패킷에 대한 응답을 보냄
  * UDP: 신뢰성이 보장하지 않는 프로토콜
* application 계층
  * 소켓을 기반으로 완성하는 프로토콜을 의미

> #### Chapter 04-2. TCP/IP 구현
* TCP 서버의 기본적인 함수 호출 순서
  1. socket() : 소켓 생성
  2. bind() : 소켓 주소 할당
  3. listen(): 연결 요청 대기 상태
    * 연결 요청을 받아들여 연결 요청 대기 큐에 쌓아둠
  4. accept(): 연결 허용
    * accpet 함수가 호출되면 운영체제는 소켓을 새로 생성하여 1:1 통신을 하게 됨
    * 첫번째 인자: 서버 소켓의 파일 디스크립터 전달
    * 두번째 인자: 연결 요청을 한 클라이언트의 주소 정보를 담을 변수의 주소 값
    * 세번째 인자: 클라이언트의 주소 정보 길이가 바이트 단위로 전달
  5. read(), write(): 데이터 송수신
  6. close(): 연결 종료
* TCP 클라이언트의 기보적인 함수호출 순서
  1. socket() : 소켓 생성
  2. connet() : 연결 요청
    * 첫번째 인자: 연결 요청을 하고자 하는 파일 디스크립터
    * 두번째 인자: 연결하고자 하는 서버의 주소 정보
    * 세번째 인자: 해당 주소 정보를 담는  변수의 크기
  3. read(), write(): 데이터 송수신
  4. close(): 연결 종료

TCP 기반 서버, 클라이언트의 함수 호출 관계
linsten  연결요청 대기 상태 accept 호출하여 클라이언트로부터 요청 올 때까지 기다림 즉, accept 함수가 blocking 함수라고 보면 됨.
 이렇게 해서 서버 측은 blocking상태에 놓이고, 클라이언트측에서 소벳 생성하고 connet를 통해 연결 요청 보냄. 이는 listen 후에 전송이 되어도 되고 accept 후에 전송되어도 됨. 그리고 connet 호출 후 서버 측에서 accept를 할 때까지 blocking 상태에 놓이게 됨. 서버가 accpet 하면 연결이 되고 연결 되면 데이터 송수신. 마지막에 연결 종료할 때는 close 호출하여 종료.
 * 서버의 listen 함수 호출 이후에야 클라이언트의 connet 함수 호출이 유효하다! 따라서 서버가 먼저 수행이 되어야한다.

 > #### Chapter 04- ?
 * iterative 서버의 구현
 accpet 함수를 단독 호출하면서 여러 클라이언트에게 서비스를 제공해주는 방법이다. 그러나 동시에 둘 이상의 클라이언트에게 서비스를 제공할 수 있는 모델은 아니다.(1:1모델)
   * 멀티 프로세서 등을 활용해야 동시에 서비스 제공 가능
* 서버 코드의 일부
  * 반복문을 활용하여 연결 요청 받아들임
* 에코 클라이언트의 문제점
  * 5장에서 자세히 설명

윈도우 진도 X

과제: 에코 서버와 에코 클라이언트 작성